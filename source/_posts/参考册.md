---
title: 参考册
tags:
  - C语言
categories: 手册
abbrlink: fced4b64
date: 2020-04-25 22:23:00
---


## 控制字符

|  二进制   | 十进制 | 十六进制 | 缩写 | 脱出字符表示法 |            名称 / 意义             |
| :-------: | :----: | :------: | :--: | :------------: | :--------------------------------: |
| 0000 0000 |   0    |    00    | NUL  |       ^@       |            空字符(Null)            |
| 0000 0001 |   1    |    01    | SOH  |       ^A       |              标题开始              |
| 0000 0010 |   2    |    02    | STX  |       ^B       |              本文开始              |
| 0000 0011 |   3    |    03    | ETX  |       ^C       |              本文结束              |
| 0000 0100 |   4    |    04    | EOT  |       ^D       |              传输结束              |
| 0000 0101 |   5    |    05    | ENQ  |       ^E       |                请求                |
| 0000 0110 |   6    |    06    | ACK  |       ^F       |              确认回应              |
| 0000 0111 |   7    |    07    | BEL  |       ^G       |                响铃                |
| 0000 1000 |   8    |    08    |  BS  |       ^H       |                退格                |
| 0000 1001 |   9    |    09    |  HT  |       ^I       |            水平定位符号            |
| 0000 1010 |   10   |    0A    |  LF  |       ^J       |               换行建               |
| 0000 1011 |   11   |    0B    |  VT  |       ^k       |            垂直定位符号            |
| 0000 1100 |   12   |    0C    |  FF  |       ^L       |               换页键               |
| 0000 1101 |   13   |    0D    |  CR  |       ^M       |              CR(字符)              |
| 0000 1110 |   14   |    0E    |  SO  |       ^N       |        取消变化 (Shift out)        |
| 0000 1111 |   15   |    0F    |  SI  |       ^O       |        启用变换 (Shift in)         |
| 0001 0000 |   16   |    10    | DLE  |       ^P       |            跳出数据通讯            |
| 0001 0001 |   17   |    11    | DC1  |       ^Q       | 设备控制一 (XON 激活软件速度控制)  |
| 0001 0010 |   18   |    12    | DC2  |       ^R       |             设备控制二             |
| 0001 0011 |   19   |    13    | DC3  |       ^S       | 设备控制三 (XOFF 停用软件速度控制) |
| 0001 0100 |   20   |    14    | DC4  |       ^T       |             设备控制四             |
| 0001 0101 |   21   |    15    | NAK  |       ^U       |            确认失败回应            |
| 0001 0110 |   22   |    18    | SYN  |       ^V       |             同步用暂停             |
| 0001 0111 |   23   |    19    | ETB  |       ^W       |            区块传输结束            |
| 0001 1000 |   24   |    18    | CAN  |       ^X       |                取消                |
| 0001 1001 |   25   |    19    |  EM  |       ^Y       |            连线介质中断            |
| 0001 1010 |   26   |    1A    | SUB  |       ^Z       |                替换                |
| 0001 1011 |   27   |    1B    | ESC  |       ^[       |               退出键               |
| 0001 1100 |   28   |    1C    |  FS  |       ^\       |             文件分割符             |
| 0001 1101 |   29   |    1D    |  GS  |       ^]       |             组群分隔符             |
| 0001 1110 |   30   |    1E    |  RS  |       ^^       |             记录分隔符             |
| 0001 1111 |   31   |    1F    |  US  |       ^_       |             单元分隔符             |
| 0111 1111 |  127   |    7F    | DEL  |       ^?       |             Delete字符             |

------



## 可显示字符

| 二进制 | 十进制 | 十六进制 | 图形 |      | 二进制 | 十进制 | 十六进制 | 图形 |
| :----: | :----: | :------: | :--: | ---- | :----: | :----: | :------: | :--: |
| 0010 0000  |   32   | 20 | (space) |      | 0101 0000  |   80   | 50 | P |
| 0010 0001  |   33   | 21 | ! |      | 0101 0001  |   81   | 51 | Q |
| 0010 0010  |   34   | 22 | " |      | 0101 0010  |   82   | 52 | R |
| 0010 0011  |   35   | 23 | # |      | 0101 0011  |   83   | 53 | S |
| 0010 0100  |   36   | 24 | $ |      | 0101 0100  |   84   | 54 | T |
| 0010 0101  |   37   | 25 | % |      | 0101 0101  |   85   | 55 | U |
| 0010 0110  |   38   | 26 | & |      | 0101 0110  |   86   | 56 | V |
| 0010 0111  |   39   | 27 | ' |      | 0101 0111  |   87   | 57 | W |
| 0010 1000  |   40   | 28 | ( |      | 0101 1000  |   88   | 58 | X |
| 0010 1001  |   41   | 29 | ) |      | 0101 1001  |   89   | 59 | Y |
| 0010 1010  |   42   | 2A | * |      | 0101 1010  |   90   | 5A | Z |
| 0010 1011  |   43   | 2B | + |      | 0101 1011  |   91   | 5B | [ |
| 0010 1100  |   44   | 2C | , |      | 0101 1100  |   92   | 5C | \ |
| 0010 1101  |   45   | 2D | - |      | 0101 1101  |   93   | 5D | ] |
| 0010 1110  |   46   | 2E | . |      | 0101 1110  |   94   | 5E | ^ |
| 0010 1111  |   47   | 2F | / |      | 0101 1111  |   95   | 5F | _ |
| 0011 0000  |   48   | 30 | 0 |      | 0110 0000  |   96   | 60 | ` |
| 0011 0001  |   49   | 31 | 1 |      | 0110 0001  |   97   | 61 | a |
| 0011 0010  |   50   | 32 | 2 |      | 0110 0010  |   98   | 62 | b |
| 0011 0011  |   51   | 33 | 3 |      | 0110 0011  |   99   | 63 | c |
| 0011 0100  |   52   | 34 | 4 |      | 0110 0100  |   100   | 64 | d |
| 0011 0101  |   53   | 35 | 5 |      | 0110 0101  |   101   | 65 | e |
| 0011 0110  |   54   | 36 | 6 |      | 0110 0110  |   102   | 66 | f |
| 0011 0111  |   55   | 37 | 7 |      | 0110 0111  |   103   | 67 | g |
| 0011 1000  |   56   | 38 | 8 |      | 0110 1000  |   104   | 68 | h |
| 0011 1001  |   57   | 39 | 9 |      | 0110 1001  |   105   | 69 | i |
| 0011 1010  |   58   | 3A | : |      | 0110 1010  |   106   | 6A | j |
| 0011 1011  |   59   | 3B | ; |      | 0110 1011  |   107   | 6B | k |
| 0011 1100  |   60   | 3C | < |      | 0110 1100  |   108   | 6C | l |
| 0011 1101  |   61   | 3D | = |      | 0110 1101  |   109   | 6D | m |
| 0011 1110  |   62   | 3E | > |      | 0110 1110  |   110   | 6E | n |
| 0011 1111  |   63   | 3F | ? |      | 0110 1111  |   111   | 6F | o |
| 0100 0000  |   64   | 40 | @ |      | 0111 0000  |   112   | 70 | p |
| 0100 0001  |   65   | 41 | A |      | 0111 0001  |   113   | 71 | q |
| 0100 0010  |   66   | 42 | B |      | 0111 0010  |   114   | 72 | r |
| 0100 0011  |   67   | 43 | C |      | 0111 0011  |   115   | 73 | s |
| 0100 0100  |   68   | 44 | D |      | 0111 0100  |   116   | 74 | t |
| 0100 0101  |   69   | 45 | E |      | 0111 0101  |   117   | 75 | u |
| 0100 0110  |   70   | 46 | F |      | 0111 0110  |   118   | 76 | v |
| 0100 0111  |   71   | 47 | G |      | 0111 0111  |   119   | 77 | w |
| 0100 1000  |   72   | 48 | H |      | 0111 1000  |   120   | 78 | x |
| 0100 1001  |   73   | 49 | I |      | 0111 1001  |   121   | 79 | y |
| 0100 1010  |   74   | 4A | J |      | 0111 1010  |   122   | 7A | z |
| 0100 1011  |   75   | 4B | K |      | 0111 1011  |   123   | 7B | { |
| 0100 1100  |   76   | 4C | L |      | 0111 1100  |   124   | 7C | \| |
| 0100 1101  |   77   | 4D | M |      | 0111 1101  |   125   | 7D | } |
| 0100 1110  |   78   | 4E | N |      | 0111 1110  |   126   | 7E | ~ |
| 0100 1111  |   79   | 4F | O |      |           |      |  |  |

------



## 五种存储类别

|   存储类别   | 存储器 | 作用域 | 链接 |           声明方式            |
| :----------: | ------ | :----: | :--: | :---------------------------: |
|     自动     | 自动   |   块   |  无  |             块内              |
|    寄存器    | 自动   |   块   |  无  |   块内，使用关键字 register   |
|  静态无链接  | 静态   |   块   |  无  |    块内，使用关键字 static    |
| 静态外部链接 | 静态   |  文件  | 外部 |          所有函数外           |
| 静态内部链接 | 静态   |  文件  | 内部 | 所有函数外，使用关键字 static |

------

## fopen的参数

| 模式字符串                                                   | 含义                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| "r"                                                          | 以读模式打开文件                                             |
| "w"                                                          | 以写模式打开文件，把现有文件的长度截为0，如果文件不存在，则创建一个新文件 |
| "a"                                                          | 以写模式打开文件，把现有文件末尾添加内容，如果文件不存在，则创建一个新文件 |
| "a+"                                                         | 以更新模式打开文件（即可以读写文件）                         |
| "w+"                                                         | 以更新模式打开文件（即，读和写），如果文件存在，则将其长度截为0；如果文件不存在，则创建一个新文件 |
| "a+"                                                         | 以跟新模式打开文件（即，读和写），在现有文件的末尾添加内容，如果文件不存在则创建一个新文件；可以读整个文件，但是只能从末尾添加内容 |
| "rb"、"wb"、"ab"、"ab+"、"a+b"、"wb+"、<br/>"w+b"、"ab+"、"a+b" | 与上一个模式类似，但是以二进制模式而不是文本模式打开文件     |
| "wx"、"wbx"、"w+x"、<br>"wb+x"或"w+bx"                       | （C11）类似非 x 模式，但是如果文件已存在或以独占模式打开文件，则打开文件失败 |



------




## 常用字符处理函数 (ctype.h)

``` c
int isalnum(int c);
```
检查字符是否为数字或字母; (0~9, a~z, A~Z)

``` c
int isalpha(int c);
```
检查字符是否为字母; （a~z, A~Z)

``` c
int iscntrl(int c);
```
检查字符是否为控制字符; (八进制000~037以及177的字符)

``` c
int isdigit(int c);
```
检查字符是否为十进制数字; (0~9)

```c
int isgraph(int c);
```
检查字符是否为图形表示，依赖于使用语言的环境; (0~9, a~z, A~Z, 以及标点符号)

```c
int islower(int c);
```
检查字符是否为小写的字符; (a~z)

```c
int isprint(int c);
```
检查字符是否为可打印的; (数字、字母、标点符号、空白字符)

```c
int ispunct(int c);
```
检查字符是否为标点符号; (! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ ] ^ _ ` { | } ~ 等)

```c
int isspace(int c);
```
检查字符是否为空白字符; (TAB、换行、垂直TAB、换页、回车、空格)

```c
int isupper(int c);
```
检查字符是否为大写字母; (A~Z)

```c
int isxdigit(int c);
```
检查字符是否为十六进制数字; (0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f)

```c
int tolower(int c);
```
转换字符为小写字母，并返回该字符;

```c
int toupper(int c);
```
转换字符为大写字母，并返回该字符;

-----



## 常用字符串操作函数 (string.h)
```c
size_t strlen(const char *str);
```
计算字符串 str 的长度，直到空结束字符''，不包括空结束字符。

``` c
char *strcpy(char *dest, const char *src);
```
把 src 所指向的字符串复制到 dest。

``` c
char *strncpy(char *dest, const char *src, size_t n);
```
同上，把 src 所指向的字符串的前n个字符复制到 dest。

``` c
char *strcat(char *dest,const char *src);
```
把 src 所指向的字符串追加到 dest 所指向的字符串结尾，实现字符串的连接。

``` c
char *strncat(char *dest, const char *src, size_t n);
```
同上，把 src 所指字符串的前n个字符添加到 dest 所指字符串的结尾处，并覆盖 dest 所指字符串结尾的''，实现字符串的连接。

``` c
char *strchr(const char *str, int c);
```
在参数 str 所指向的字符串中搜索第一次出现字符 c (无符号字符) 的位置，如果 str 中没有c，则返回NULL。

``` c
char *strrchr(const char *str, int c);
```
在参数 str 所指向的字符串中搜索最后一次出现字符 c (无符号字符) 的位置，如果 str 中没有c，则返回NULL。

``` c
char *strstr(const char *str1, const char *str2);
```
若 str2 是 str1 的子串，则返回 str2 在 str1 的首次出现的地址；如果str2不是str1的子串，则返回NULL。

``` c
int strcmp(const char *str1, const char *str2);
```
把 str 所指向的字符串和 str2 所指向的字符串进行比较，当str1<str2时，返回一个负数；当str1==str2时，返回零；当str1>str2时，返回一个正数。

``` c
int strncmp(const char *str1, const char *str2, size_t n);
```
同上，把 str1 所指字符串的前n个字符和 str2 进行比较

``` c
int atoi(const char *nptr);
```
字符串转int整型变量

``` c
char *itoa(int value, char *str, int base);
```
整数数值转字符串

## 运算符优先级
| 优先级 | 运算符 |   名称或含义   |           使用形式            | 结合方向 |       说明       |
| :----: | :----: | :------------: | :---------------------------: | :------: | :--------------: |
|   1    |   []   |    数组下标    |      数组名[整型表达式]       |  左到右  |                  |
|   1    |   ()   |     圆括号     |   （表达式）/函数名(形参表)   |  左到右  |                  |
|   1    |   .    | 成员选择(对象) |          对象.成员名          |  左到右  |                  |
|   1    |   ->   | 成员选择(指针) |       对象指针->成员名        |  左到右  |                  |
|   2    |   -    |   负号运算符   |        -算术类型表达式        |  右到左  |    单目运算符    |
|   2    | (type) |  强制类型转换  |   (纯量数据类型)纯量表达式    |  右到左  |                  |
|   2    |   ++   |   自增运算符   |  ++纯量类型可修改左值表达式   |  右到左  |    单目运算符    |
|   2    |   --   |   自减运算符   |  --纯量类型可修改左值表达式   |  右到左  |    单目运算符    |
|   2    |   *    |   取值运算符   |        *指针类型表达式        |  右到左  |    单目运算符    |
|   2    |   &    |  取地址运算符  |            &表达式            |  右到左  |    单目运算符    |
|   2    |   !    |  逻辑非运算符  |        !纯量类型表达式        |  右到左  |    单目运算符    |
|   2    |   ~    | 按位取反运算符 |          ~整型表达式          |  右到左  |    单目运算符    |
|   2    | sizeof |   长度运算符   | sizeof 表达式<br>sizeof(类型) |  右到左  |                  |
|   3    |   /    |       除       |         表达式/表达式         |  左到右  |    双目运算符    |
|   3    |   *    |       乘       |         表达式*表达式         |  左到右  |    双目运算符    |
|   3    |   %    |   求余(取模)   |     整型表达式%整型表达式     |  左到右  |    双目运算符    |
|   4    |   +    |       加       |         表达式+表达式         |  左到右  |    双目运算符    |
|   4    |   -    |       减       |         表达式-表达式         |  左到右  |    双目运算符    |
|   5    |   <<   |      左移      |    整型表达式<<整型表达式     |  左到右  |    双目运算符    |
|   5    |   >>   |      右移      |    整型表达式>>整型表达式     |  左到右  |    双目运算符    |
|   6    |   >    |      大于      |         表达式>表达式         |  左到右  |    双目运算符    |
|   6    |   >=   |    大于等于    |        表达式>=表达式         |  左到右  |    双目运算符    |
|   6    |   <    |      小于      |         表达式<表达式         |  左到右  |    双目运算符    |
|   6    |   <=   |    小于等于    |        表达式<=表达式         |  左到右  |    双目运算符    |
|   7    |   ==   |      等于      |        表达式==表达式         |  左到右  |    双目运算符    |
|   7    |   !=   |     不等于     |        表达式!= 表达式        |  左到右  |    双目运算符    |
|   8    |   &    |     按位与     |     整型表达式&整型表达式     |  左到右  |    双目运算符    |
|   9    |   ^    |    按位异或    |     整型表达式^整型表达式     |  左到右  |    双目运算符    |
|   10   |   \|   |     按位或     |    整型表达式\|整型表达式     |  左到右  |    双目运算符    |
|   11   |   &&   |     逻辑与     |        表达式&&表达式         |  左到右  |    双目运算符    |
|   12   |  \|\|  |     逻辑或     |       表达式\|\|表达式        |  左到右  |    双目运算符    |
|   13   |   ?    |   条件运算符   |   表达式1? 表达式2: 表达式3   |  左到右  |    三目运算符    |
|   14   |   =    |   赋值运算符   |    可修改左值表达式=表达式    |  右到左  |                  |
|   14   |   /=   |    除后赋值    |   可修改左值表达式/=表达式    |  右到左  |                  |
|   14   |   *=   |    乘后赋值    |   可修改左值表达式*=表达式    |  右到左  |                  |
|   14   |   %=   |   取模后赋值   |   可修改左值表达式%=表达式    |  右到左  |                  |
|   14   |   +=   |    加后赋值    |   可修改左值表达式+=表达式    |  右到左  |                  |
|   14   |   -=   |    减后赋值    |   可修改左值表达式-=表达式    |  右到左  |                  |
|   14   |  <<=   |   左移后赋值   |   可修改左值表达式<<=表达式   |  右到左  |                  |
|   14   |  >>=   |   右移后赋值   |   可修改左值表达式>>=表达式   |  右到左  |                  |
|   14   |   &=   |  按位与后赋值  |   可修改左值表达式&=表达式    |  右到左  |                  |
|   14   |   ^=   | 按位异或后赋值 |   可修改左值表达式^=表达式    |  右到左  |                  |
|   14   |  \|=   |  按位或后赋值  |   可修改左值表达式\|=表达式   |  右到左  |                  |
|   15   |   ,    |   逗号运算符   |        表达式,表达式,…        |  左到右  | 从左向右顺序结合 |

## CPP示例代码(带注释)

### 指针的操作

```c
//指针的部分操作 p295
//先记录一个问题 笔记本也有一些相关记录     //p289下方
//指针所指向的类型的地址是谁的地址， 也就是一个类型 比如double类型有4个字节
//那这个指针指向哪一个字节作为地址呢？ 书中提到通常是该对象的第一个字节的地址
//ptr_ops.c
#include <stdio.h>
int main(void)
{
    int urn[5] = {100, 200, 300, 400, 500};
    int *ptr1, *ptr2, *ptr3;
    ptr1 = urn;     //此时指针prt1的值为urn[1]的地址， 在解析这个地址后的值为100
    ptr2 = &urn[2]; //此时指针prt2的值为urn[2]的地址， 在解析这个地址后的值为300
    printf("pointer value, dereferenced pointer, pointer address:\n");
    printf("ptr1 = %p, *ptr1 =%d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);

    // 指针加法 p289      //书中讲过指针加正整数（暂且）的结果就是加对应个存储单位也就是int的字节数
    //那也就有了重要的一点这个存储在为在我的系统上占用多少个字节
    //目前为short型占用2字节，int型占用4字节， float型占用4字节， double型占用8字节
    //printf("short类型的变量占用%d字节 int类型的变量占用%d字节 double类型的变量占用%d字节 float类型的变量占用%d字节",sizeof(short), sizeof(int), sizeof(double), sizeof(float));
    ptr3 = ptr1 + 4;    //指针prt3的值为 指针prt1(指向数组urn的首地址) 加上 4 个存储单元 和 urn[0] + 4 相同
    printf("\nadding an int to a pointer:\n");
    printf("ptr1 + 4 = %p, *(ptr1 + 4) = %d\n", ptr1 + 4, *(ptr1 + 4));

    ptr1++; // 递增指针——数组urn[0 + 1];     //改变了指针所指向的地址，所以解析出来的值也变了，而指针本身的地址没有变
    printf("\nvalues after ptr1++:\n");
    printf("ptr1 = %p, *ptr1 =%d, &ptr1 = %p\n", ptr1, *ptr1, &ptr1);

    ptr2--; // 递减指针——数组urn[2 - 1];     //改变了指针所指向的地址，所以解析出来的值也变了，而指针本身的地址没有变
    printf("\nvalues after --ptr2:\n");
    printf("ptr2 = %p, *ptr2 = %d, &ptr2 = %p\n", ptr2, *ptr2, &ptr2);

    --ptr1; // 恢复为初始值
    ++ptr2; // 恢复为初始值
    printf("\nPointers reset to original values:\n");
    printf("ptr1 = %p, ptr2 = %p\n", ptr1, ptr2);   //打印指针一开始指向的地址

    // 一个指针减去另一个指针
    printf("\nsubtracting one pointer from another:\n");    //1.指针可以相减 2.结果为什么类型 应该无所谓 反正是用来做一些整数的操作
    printf("ptr2 = %p, ptr1 = %p, ptr2 - ptr1 = %td\n", ptr2, ptr1, ptr2 - ptr1);

    // 一个指针减去一个整数
    printf("\nsubtracting an int from a pointer:\n");
    printf("ptr3 = %p, ptr3 - 2 = %p\n", ptr3, ptr3 - 2);   //这里应该是减去两个存储单位
    return 0;                                               //也就是prt3现在指向urn[2] 所以值是urn[2]的地址
}
```



### 位字段

```c
/*
0010 0101 0000 0111     true, YELLOW, true, GREEN, DASHED           // 初始化
0010 0101 0000 0001     box.us_view &= ~FILL_MASK;                  // 把表示填充色的位清 0
0010 0101 0000 1101     box.us_view |= (FILL_BLUE | FILL_GREEN);    // 重置填充色
0010 0101 0000 1100     box.us_view ^= OPAQUE;                      // 切换是否透明的位
0010 0111 0000 1100     box.us_view |= BORDER_RED;                  // 错误的方法
0000 0111 0000 1100     box.us_view &= ~STYLE_MASK;                 // 把样式的位清 0
0001 0111 0000 1100     box.us_view |= B_DOTTED;                    // 把样式设置为点
 2 2   31    4   31
   边 边 显     填 是                       // win10把这些结构载入内存的方式和我们预期的是不同的
   框 框 示     充 否                       // pdf 1181 书中514   用linux系统就能正常显示
   风 颜 边     颜 透
   格 色 框     色 明

OPAQUE       0x1          0000 0000 0000 0001       // 不透明           ||        SOLID  0                    // 实线线段
FILL_RED     0x2          0000 0000 0000 0010       // 填充红色         ||        DOTTED 1                    // 点组成的线段
FILL_GREEN   0x4          0000 0000 0000 ?0100?       // 填充绿色         ||        DASHED 2                    // 破折号组成的线段
FILL_BLUE    0x8          0000 0000 0000 ?1000?       // 填充蓝色         ||        BLUE   4                    // 蓝色
FILL_MASK    0xE          0000 0000 0000 1110?       // 填充掩码         ||        GREEN  2                    // 绿色
BORDER       0x100        0000 0001 0000 0000?       // 边框             ||        RED    1                    // 红色
BORDER_RED   0x200        0000 0010 0000 0000       // 边框红色         ||        BLACK  0                    // 黑色
BORDER_GREEN 0x400        0000 0100 0000 0000       // 边框绿色         ||        YELLOW (RED | GREEN)        // 黄色
BORDER_BLUE  0x800        0000 1000 0000 0000       // 边框蓝色         ||        MAGENTA (RED | BLUE)        // 洋红色
BORDER_MASK  0xE00        0000 1110 0000 0000?       // 边框掩码         ||        CYAN (GREEN | BLUE)         // 青色
B_SOLID      0            0000 0000 0000 0000       // 实线掩码         ||        WHITE (RED | GREEN | BLUE)  // 白色
B_DOTTED     0x1000       0001 0000 0000 0000?       // 点线掩码         ||
B_DASHED     0x2000       0010 0000 0000 0000?       // 虚线掩码         ||
STYLE_MASK   0x3000       0011 0000 0000 0000?       // 风格掩码         ||

掩码要~操作并不是多此一举 而是使掩码更加显意
*/
/* dualview.c -- 位字段和按位运算符 */
#include <stdio.h>
#include <stdbool.h>
#include <limits.h>
/* 位字段符号常量 */
/* 边框线样式 */
#define SOLID 0  // 实线线段
#define DOTTED 1 // 点组成的线段
#define DASHED 2 // 破折号组成的线段
/* 三原色 */
#define BLUE 4
#define GREEN 2
#define RED 1
/* 混合颜色 */
#define BLACK 0                    // 黑色
#define YELLOW (RED | GREEN)       // 黄色
#define MAGENTA (RED | BLUE)       // 洋红色
#define CYAN (GREEN | BLUE)        // 青色
#define WHITE (RED | GREEN | BLUE) // 白色



/* 按位方法中用到的符号常量 */
#define OPAQUE 0x1         // 不透明        // 1
#define FILL_BLUE 0x8      // 填充蓝色
#define FILL_GREEN 0x4     // 填充绿色
#define FILL_RED 0x2       // 填充红色
#define FILL_MASK 0xE      // 填充掩码      // 5

#define BORDER 0x100       // 边框          // 1
#define BORDER_BLUE 0x800  // 边框蓝色
#define BORDER_GREEN 0x400 // 边框绿色
#define BORDER_RED 0x200   // 边框红色
#define BORDER_MASK 0xE00  // 边框掩码      // 5

#define B_SOLID 0          // 实线掩码
#define B_DOTTED 0x1000    // 点线掩码
#define B_DASHED 0x2000    // 虚线掩码
#define STYLE_MASK 0x3000  // 风格掩码      // 5

const char *colors[8] = {"black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"};
struct box_props
{
    bool opaque : 1;
    unsigned int fill_color : 3;
    unsigned int : 4;               // 到这里正好是8个字节 显得整齐
    bool show_border : 1;
    unsigned int border_color : 3;
    unsigned int border_style : 2;
    unsigned int : 2;               // 到这里正好是8个字节 显得整齐
};
union Views /* 把数据看作结构或unsigned short类型的变量 */
{
    struct box_props st_view;
    unsigned short us_view;
};
void show_settings(const struct box_props *pb); // 通过结构显示 box 的属性
void show_settings1(unsigned short);            // 通过unsigned short来显示 box 的属性
char *itobs(int n, char *ps);                   // 整数转二进制字符串形式
int main(void)
{
    /* 创建Views联合，并初始化initialize struct box view */
    union Views box = {{true, YELLOW, true, GREEN, DASHED}}; // 新建的联合只允许初始化第一个成员
    char bin_str[8 * sizeof(unsigned int) + 1];              // bin_str

    printf("Original box settings:\n");                   //  1
    show_settings(&box.st_view);                          //  2
    printf("\nBox settings using unsigned int view:\n");  //  3
    show_settings1(box.us_view);                          //  4
    printf("bits are %s\n", itobs(box.us_view, bin_str)); //  5

    box.us_view &= ~FILL_MASK;               /* 把表示填充色的位清0 */
    box.us_view |= (FILL_BLUE | FILL_GREEN); /* 重置填充色 */
    box.us_view ^= OPAQUE;                   /* 切换是否透明的位 */
    box.us_view |= BORDER_RED;               /* 错误的方法 */
    box.us_view &= ~STYLE_MASK;              /* 把样式的位清0 */
    box.us_view |= B_DOTTED;                 /* 把样式设置为点 */

    printf("\nModified box settings:\n");                 //  1
    show_settings(&box.st_view);                          //  2
    printf("\nBox settings using unsigned int view:\n");  //  3
    show_settings1(box.us_view);                          //  4
    printf("bits are %s\n", itobs(box.us_view, bin_str)); //  5

    return 0;
}
void show_settings(const struct box_props *pb)
{
    printf("Box is %s.\n", pb->opaque == true ? "opaque" : "transparent");      // 不透明 : 透明
    printf("The fill color is %s.\n", colors[pb->fill_color]);                  // pb->fill_color是一个red加green为3 也就是colors[3]
    printf("Border %s.\n", pb->show_border == true ? "shown" : "not shown");    // 是否展示边框
    printf("The border color is %s.\n", colors[pb->border_color]);              // colors[2]   绿色
    printf("The border style is ");                                             // 边框风格
    switch (pb->border_style)   // 值为正数
    {
    case SOLID:
        printf("solid.\n");
        break;
    case DOTTED:
        printf("dotted.\n");
        break;
    case DASHED:                // dashed为 2
        printf("dashed.\n");
        break;
    default:
        printf("unknown type.\n");
    }
}
void show_settings1(unsigned short us)  // short为2个字节 16位
{
    printf("box is %s.\n", (us & OPAQUE) == OPAQUE ? "opaque" : "transparent"); //us和OPAQUE在二进制层面上进行0号位对比
    printf("The fill color is %s.\n", colors[(us >> 1) & 07]);
    printf("Border %s.\n", (us & BORDER) == BORDER ? "shown" : "not shown");    //us和BORDER在二进制层面上进行8号位对比
    printf("The border style is ");
    switch (us & STYLE_MASK)
    {
    case B_SOLID:
        printf("solid.\n");
        break;
    case B_DOTTED:
        printf("dotted.\n");
        break;
    case B_DASHED:
        printf("dashed.\n");
        break;
    default:
        printf("unknown type.\n");
    }
    printf("The border color is %s.\n", colors[(us >> 9) & 07]);
}

char *itobs(int n, char *ps)
{
    int i;
    const static int size = CHAR_BIT * sizeof(int);
    for (i = size - 1; i >= 0; i--, n >>= 1)
        ps[i] = (01 & n) + '0';
    ps[size] = '\0';
    return ps;
}

```

### 指针和二维数组

```cc
/* zippo1.c -- zippo的相关信息 */
#include <stdio.h>
int main(void)
{
    int zippo[4][2] =
        {{2, 4}, {6, 8}, {1, 3}, {5, 7}};
    //zippo是这个数组的首元素的地址 而zippo的首元素是一个内含两个int值的数组
    //zippo的值和 &zippo[0]的值相同
    printf("%p\n", zippo);     //首元素的地址
    printf("%p\n", &zippo[0]); //首元素的地址
///////////////////////////////////////////////////////////
    //zippo[0]是一个内含两个整数的数组 zippo[0]的值和它首元素的地址相同
    //简而言之，zippo[0]是一 个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地 址。
    //由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo 和zippo[0]的值相同。
    printf("%x\n", zippo[0]); //首元素的值

//-------------------------------------------------------------
//给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo和zippo[0]不同，因为zippo指向的对象占用了两个int大小，
//而zippo[0]指向的 对象只占用一个int大小。因此， zippo + 1和zippo[0] + 1的值不同。
    printf("zippo = %x, zippo + 1 = %x\n ", zippo, zippo + 1);
    printf("zippo[0] = %x, zippo[0] + 1 = %x\n", zippo[0], zippo[0] + 1);   //值就是地址  一个加两个存储单位 一个加一个存储单位
    printf("以上为%d转换说明    以下为%p转换说明\n");
    printf("zippo = %p, zippo + 1 = %p\n", zippo, zippo + 1);
    printf("zippo[0] = %p, zippo[0] + 1 = %p\n", zippo[0], zippo[0] + 1);
    printf(" *zippo = %p, *zippo + 1 = %p\n", *zippo, *zippo + 1);



//-------------------------------------------------------------
/*因为zippo[0]是该数组首元素（zippo[0] [0]）的地址，所以*(zippo[0])表示储存在zippo[0][0]上的值
（即一个int类型 的值）。与此类似，*zippo代表该数组首元素（zippo[0]）的值，
但是 zippo[0]本身是一个int类型值的地址。该值的地址是&zippo[0][0]，所以 *zippo就是&zippo[0][0]。*/

//zippo[0]是该数组首元素（zippo[0] [0]）的地址
    //printf("%x\n", zippo[0]); //以十六进制打印zippo[0]的值
    printf("%p\n", &zippo[0]);  //%p转换说明打印zippo[0]的地址
    printf("%p\n", &zippo[0][0]);
//作为地址的zippo[0] 在解引用之后就是zippo[0][0]的值
    printf("  *zippo[0] = %d\n", *zippo[0]);
    printf("zippo[0][0] = %d\n", zippo[0][0]);
//因上作为地址的zippo 在解引用之后就是zippo[0]的值      //注意 zippo[0]本身是一个int类型值的地址
    printf("  *zippo = %x\n", *zippo);
    printf("zippo[0] = %x\n", zippo[0]);
    printf("&zippo[0][0] = %p\n", &zippo[0][0]);    //而zippo[0]的值是zippo[0][0]的地址，所以*zippo就是&zippo[0][0]

/*对两个表达式应用解引用运算符表明，**zippo与 *&zippo[0][0]等价，这相当于zippo[0][0]，
即一个int类型的值。简而言之， zippo是地址的地址，必须解引用两次才能获得原始值。
地址的地址或指针的指针是就是双重间接（double indirection）的例子*/
    //也就是打印zippo[0][0]的几种方式 用于处理二维数组的函数
    printf("zippo[0][0] = %d", zippo[0][0]);
    printf("zippo[0][0] = %d", *zippo[0]);  //因为zippp[0]的值就是zippo[0][0]的地址
    printf("zippo[0][0] = %d", **zippo);    //因为zippo的值就是zippo[0]的地址 所以第一次解引用后就等于zippo[0]的地址 然后解引用zippo[0]的值就是zippo[0][0]的地址

//二维数组的表示形式 也是数组形式和指针形式
    printf("zippo[2][1] = %d\n", zippo[2][1]);
    printf("*(*(zippo+2) + 1) = %d\n", *(*(zippo + 2) + 1));

// 书中303页图10.5最下面的先解引用后加1 所要

    return 0;
}
```

### 二叉树
![其中两个递归函数的遍历顺序](https://s1.ax1x.com/2020/06/23/NtIxLF.png)
``` c
/* tree.h -- 二叉查找数 */      // 一个头文件 两个源文件
/* 树种不允许有重复的项 */      // 611
#ifndef _TREE_H_
#define _TREE_H_
#include <stdbool.h>
/* 根据具体情况重新定义 Item */
#define SLEN 20
typedef struct item
{
    char petname[SLEN];
    char petkind[SLEN];
} Item;
#define MAXITEMS 10
typedef struct trnode
{
    Item item;
    struct trnode *left;  /* 指向左分支的指针 */
    struct trnode *right; /* 指向右分支的指针 */
} Trnode;
typedef struct tree
{
    Trnode *root; /* 指向根节点的指针 */
    int size;     /* 树的项数 */
} Tree;
/* 函数原型 */
/* 操作： 把树初始化为空*/
/* 前提条件： ptree指向一个树 */
/* 后置条件： 树被初始化为空 */
void InitializeTree(Tree *ptree);
/* 操作： 确定树是否为空 */
/* 前提条件： ptree指向一个树 */
/* 后置条件： 如果树为空，该函数返回true */
/* 否则，返回false */
bool TreeIsEmpty(const Tree *ptree);
/* 操作： 确定树是否已满 */
/* 前提条件： ptree指向一个树 */
/* 后置条件： 如果树已满，该函数返回true */
/* 否则，返回false */
bool TreeIsFull(const Tree *ptree);
/* 操作： 确定树的项数 */
/* 前提条件： ptree指向一个树 */
/* 后置条件： 返回树的项数 */
int TreeItemCount(const Tree *ptree);
/* 操作： 在树中添加一个项 */
/* 前提条件： pi是待添加项的地址 */
/* ptree指向一个已初始化的树 */
/* 后置条件： 如果可以添加，该函数将在树中添加一个项 */
/* 并返回true；否则，返回false */
bool AddItem(const Item *pi, Tree *ptree);
/* 操作： 在树中查找一个项 */
/* 前提条件： pi指向一个项 */
/* ptree指向一个已初始化的树 */
/* 后置条件： 如果在树中添加一个项，该函数返回true */
/* 否则，返回false */
bool InTree(const Item *pi, const Tree *ptree);
/* 操作： 从树中删除一个项 */
/* 前提条件： pi是删除项的地址 */
/* ptree指向一个已初始化的树 */
/* 后置条件： 如果从树中成功删除一个项，该函数返回true*/
/* 否则，返回false */
bool DeleteItem(const Item *pi, Tree *ptree);
/* 操作： 把函数应用于树中的每一项 */
/* 前提条件： ptree指向一个树 */
/* pfun指向一个函数， */
/* 该函数接受一个Item类型的参数，并无返回值*/
/* 后置条件： pfun指向的这个函数为树中的每一项执行一次*/
void Traverse(const Tree *ptree, void (*pfun)(Item item));
/* 操作： 删除树中的所有内容 */
/* 前提条件： ptree指向一个已初始化的树 */
/* 后置条件： 树为空 */
void DeleteAll(Tree *ptree);
#endif

/* tree.c -- 树的支持函数 */
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "tree.h"
/* 局部数据类型 */
typedef struct pair // Tree的都是根节点 Item项目
{                   // Trnode是节点  Pair是父叶和子叶
    Trnode *parent;
    Trnode *child;
} Pair;
/* 局部函数的原型 */
static Trnode *MakeNode(const Item *pi);
static bool ToLeft(const Item *i1, const Item *i2);
static bool ToRight(const Item *i1, const Item *i2);
static void AddNode(Trnode *new_node, Trnode *root);
static void InOrder(const Trnode *root, void (*pfun)(Item item));
static Pair SeekItem(const Item *pi, const Tree *ptree);
static void DeleteNode(Trnode **ptr);
static void DeleteAllNodes(Trnode *ptr);
/* 函数定义 */
void InitializeTree(Tree *ptree) // 初始化树
{
    ptree->root = NULL;
    ptree->size = 0;
}
bool TreeIsEmpty(const Tree *ptree) // 树是空的
{
    if (ptree->root == NULL)
        return true;
    else
        return false;
}
bool TreeIsFull(const Tree *ptree) // 树是满的
{
    if (ptree->size == MAXITEMS)
        return true;
    else
        return false;
}
int TreeItemCount(const Tree *ptree) // 树中项目总量
{
    return ptree->size; // 翁恺说这样有助于日后拓展开发
}
bool AddItem(const Item *pi, Tree *ptree) // 添加一个项目到树中
{
    Trnode *new_node;
    if (TreeIsFull(ptree))
    {
        fprintf(stderr, "Tree is full\n");
        return false; /* 提前返回 */
    }
    if (SeekItem(pi, ptree).child != NULL)
    {
        fprintf(stderr, "Attempted to add duplicate item\n"); // 尝试添加重复项
        return false;                                         /* 提前返回 */
    }
    new_node = MakeNode(pi); /* 指向新节点 */
    if (new_node == NULL)    // 树没满、新节点不为NULL且不是重复的节点
    {
        fprintf(stderr, "Couldn't create node\n");
        return false; /* 提前返回 */
    }
    /* 成功创建了一个新节点 */
    ptree->size++;
    if (ptree->root == NULL)                                   /* 情况1：树为空 */
        ptree->root = new_node;                                /* 新节点为树的根节点 */
    else                                                       /* 情况2：树不为空 */
        AddNode(new_node, ptree->root); /* 在树中添加新节点 */ // 要树叶和树根
    return true;                                               /* 成功返回 */
}
bool InTree(const Item *pi, const Tree *ptree) // 树中是否有这个Item
{
    return (SeekItem(pi, ptree).child == NULL) ? false : true;
} // 如果child不为NULL则返回true
bool DeleteItem(const Item *pi, Tree *ptree) // Item和树根 匹配叶子
{
    Pair look;
    look = SeekItem(pi, ptree);
    if (look.child == NULL) // 说明没有pi这个Item 程序结束
        return false;
    if (look.parent == NULL) /* 删除根节点项 */ // 只有目标项为根是 parent才会是NULL
        DeleteNode(&ptree->root);   // 该函数一个大IF 所以三者一成 和现在这个大IF刚好一样
    else if (look.parent->left == look.child)   // 为什么不传递child
        DeleteNode(&look.parent->left);         // 因为目标是child。！ 所以现在检测的是 是左边为child 还是。。
    else    // look.parent->right == look.child
        DeleteNode(&look.parent->right);
    ptree->size--;  // 树根中 叶子数量减一
    return true;
}
void Traverse(const Tree *ptree, void (*pfun)(Item item))   // 树根 参数为叶子的函数
{
    if (ptree != NULL)                  // 树不为空 因为下面是个递归函数 所以。。
        InOrder(ptree->root, pfun);
}
void DeleteAll(Tree *ptree) // 树根
{
    if (ptree != NULL)
        DeleteAllNodes(ptree->root);    // 树根不是空的就清除掉
    ptree->root = NULL;     // 然后手动赋值树根为NULL 树叶也是
    ptree->size = 0;        // 树根是空的那也就赋值一下呗
}
/* 局部函数 */
static void InOrder(const Trnode *root, void (*pfun)(Item item))    // 树根 操作函数
{
    if (root != NULL)               // 树不为空
    {
        InOrder(root->left, pfun);  // 画出来了
        (*pfun)(root->item);
        InOrder(root->right, pfun);
    }
}
static void DeleteAllNodes(Trnode *root)
{
    Trnode *pright;     // 和InOrder递归是一样的顺序
    if (root != NULL)   // 不过因为free所以在处理节点时做了一个节点标记
    {
        pright = root->right;
        DeleteAllNodes(root->left);
        free(root);
        DeleteAllNodes(pright);
    }
}
static void AddNode(Trnode *new_node, Trnode *root) // Item转Node树叶 和树根
{
    if (ToLeft(&new_node->item, &root->item)) // 树叶中的Item和树根中的Item
    {
        if (root->left == NULL) /* 空子树 */ // 不为空就继续向下延伸
            root->left = new_node;           /* 把节点添加到此处 */
        else
            AddNode(new_node, root->left); /* 否则处理该子树 */
    }
    else if (ToRight(&new_node->item, &root->item))
    {
        if (root->right == NULL)    /* 空子树 */
            root->right = new_node; /* 把节点添加到此处 */
        else
            AddNode(new_node, root->right); /* 否则处理该子树 */
    }
    else /* 不允许有重复项*/
    {
        fprintf(stderr, "location error in AddNode()\n");
        exit(1);
    }
}
static bool ToLeft(const Item *i1, const Item *i2)      // 两个Item进行比较
{                                                       // 很明显petname和petkind
    int comp1;                                          // 两者的限制 不过需求变化后
    if ((comp1 = strcmp(i1->petname, i2->petname)) < 0) // 只需要更改Toleft和ToRight就行了
        return true;                                    // 第一个字符串小于第二个字符串返回小于0的值
    else if (comp1 == 0 && strcmp(i1->petkind, i2->petkind) < 0)
        return true; // 如果两个字符串相同且第一个字符串小于第二个字符串
    else
        return false; // 两个if都不满足就肯定是ToRight了
}
static bool ToRight(const Item *i1, const Item *i2)     // 两个Item进行比较
{
    int comp1;
    if ((comp1 = strcmp(i1->petname, i2->petname)) > 0)
        return true; // 第一个字符串小于第二个字符串返回大于0的值
    else if (comp1 == 0 && strcmp(i1->petkind, i2->petkind) > 0)
        return true; // 如果两个字符串相同且第一个字符串小于第二个字符串
    else
        return false; // 如果两个函数检测都不通过就说明重复了
}
static Trnode *MakeNode(const Item *pi)     // Item转树叶
{
    Trnode *new_node;
    new_node = (Trnode *)malloc(sizeof(Trnode));
    if (new_node != NULL)
    {
        new_node->item = *pi;
        new_node->left = NULL;
        new_node->right = NULL;
    }
    return new_node;
}
static Pair SeekItem(const Item *pi, const Tree *ptree) // 找到目标项所在位置 目标项为child 目标项上层节点为parent
{
    Pair look;
    look.parent = NULL;
    look.child = ptree->root;
    if (look.child == NULL) // 如果树根是空的
        return look;        /* 提前返回 */
    while (look.child != NULL)
    {
        if (ToLeft(pi, &(look.child->item))) // 如果第一个字符串小于第二个字符串
        {                                    // 那么就把节点定向左
            look.parent = look.child;
            look.child = look.child->left;
        }
        else if (ToRight(pi, &(look.child->item))) // 如果第一个字符串大于第二个字符串
        {                                          // 那么就把节点定向右
            look.parent = look.child;
            look.child = look.child->right;
        }
        else                                     /* 如果前两种情况都不满足，则必定是相等的情况 */
            break; /* look.child 目标项的节点 */ // 那么当前look.child就是目标项
    }                                            // 如果目标为根节点则parent为NULL
    return look;                                 /* 成功返回 */
}
static void DeleteNode(Trnode **ptr) /* ptr 是指向目标节点的父节点指针成员的地址 */
{
    Trnode *temp;
    if ((*ptr)->left == NULL) // 如果当前节点的左节点是空的
    {
        temp = *ptr;          // 缓存当前节点
        *ptr = (*ptr)->right; //
        free(temp);           // 清除第一步缓存的节点
    }
    else if ((*ptr)->right == NULL) // 如果当前节点的右节点是空的
    {
        temp = *ptr;         // 缓存当前节点 是为了清除内存空间
        *ptr = (*ptr)->left; // 这里注意一下 想不明白就想一下树的结构 这句话的确是在动left 615
        free(temp);          // 清除第一步缓存的节点所占用的内存空间
    }
    else /* 被删除的节点有两个子节点 */
    {
        for (temp = (*ptr)->left; temp->right != NULL; temp = temp->right) // 在pdf1412中看
            continue;   /* 找到重新连接右子树的位置 */
        temp->right = (*ptr)->right;    // 连接右子树
        temp = *ptr;                    // 这是上面那两个的套路
        *ptr = (*ptr)->left;            //  把left链接回来
        free(temp);                     // 然后清除缓存
    }
}

/* petclub.c -- 使用二叉查找数 */
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "tree.h"
char menu(void);
void addpet(Tree *pt);
void droppet(Tree *pt);
void showpets(const Tree *pt);
void findpet(const Tree *pt);
void printitem(Item item);
void uppercase(char *str);
char *s_gets(char *st, int n);
int main(void)
{
    Tree pets;                       // 树根
    char choice;                     // 选项载体
    InitializeTree(&pets);           // 初始化树根
    while ((choice = menu()) != 'q') // while菜单
    {
        switch (choice)
        {
        case 'a':
            addpet(&pets); // 添加
            break;
        case 'l':
            showpets(&pets); // 显示
            break;
        case 'f':
            findpet(&pets); // 查找
            break;
        case 'n':
            printf("%d pets in club\n", TreeItemCount(&pets)); // 宠物总量
            break;
        case 'd':
            droppet(&pets); // 丢掉
            break;
        default:
            puts("Switching error");
        }
    }
    DeleteAll(&pets); // 程序结束 清除所有内存空间
    puts("Bye.");
    return 0;
}
char menu(void)
{
    int ch;
    puts("Nerfville Pet Club Membership Program");
    puts("Enter the letter corresponding to your choice:");
    puts("a) add a pet l) show list of pets");
    puts("n) number of pets f) find pets");
    puts("d) delete a pet q) quit");
    while ((ch = getchar()) != EOF)
    {
        while (getchar() != '\n') /* 处理输入行的剩余内容 */
            continue;
        ch = tolower(ch);   // 字符转小写  很明显这里是作者写的不多的的除错机制
        if (strchr("alrfndq", ch) == NULL)  // 第一个字符串是否存在于第二个字符串中
            puts("Please enter an a, l, f, n, d, or q:");   // 这个menu挺不错的
        else
            break;
    }
    if (ch == EOF) /* 使程序退出 */
        ch = 'q';
    return ch;
}
void addpet(Tree *pt)   // 树根
{
    Item temp;      //
    if (TreeIsFull(pt))
        puts("No room in the club!");
    else
    {
        puts("Please enter name of pet:");
        s_gets(temp.petname, SLEN);
        puts("Please enter pet kind:");
        s_gets(temp.petkind, SLEN);
        uppercase(temp.petname);    // 所有字符转大写
        uppercase(temp.petkind);
        AddItem(&temp, pt);     // Item转树叶
    }
}
void showpets(const Tree *pt)
{
    if (TreeIsEmpty(pt))
        puts("No entries!");
    else
        Traverse(pt, printitem);    // 遍历树 InOrder递归的那个
}
void printitem(Item item)   // 自定义函数
{                           // 方便格式
    printf("Pet: %-19s Kind: %-19s\n", item.petname, item.petkind);
}
void findpet(const Tree *pt)    // 树根
{
    Item temp;
    if (TreeIsEmpty(pt))
    {
        puts("No entries!");
        return; /* 如果树为空，则退出该函数 */
    }
    puts("Please enter name of pet you wish to find:");
    s_gets(temp.petname, SLEN);
    puts("Please enter pet kind:");
    s_gets(temp.petkind, SLEN);
    uppercase(temp.petname);
    uppercase(temp.petkind);
    printf("%s the %s ", temp.petname, temp.petkind);
    if (InTree(&temp, pt))          // seekItem函数 二叉树二分查找
        printf("is a member.\n");   // 如果目标存在 则返回true
    else
        printf("is not a member.\n");
}
void droppet(Tree *pt)
{
    Item temp;
    if (TreeIsEmpty(pt))
    {
        puts("No entries!");
        return; /* 如果树为空，则退出该函数 */
    }
    puts("Please enter name of pet you wish to delete:");
    s_gets(temp.petname, SLEN);
    puts("Please enter pet kind:");
    s_gets(temp.petkind, SLEN);
    uppercase(temp.petname);
    uppercase(temp.petkind);
    printf("%s the %s ", temp.petname, temp.petkind);
    if (DeleteItem(&temp, pt))      // 同样是SeekItem
        printf("is dropped from the club.\n");
    else
        printf("is not a member.\n");
}
void uppercase(char *str)
{
    while (*str)
    {
        *str = toupper(*str);
        str++;
    }
}
char *s_gets(char *st, int n)
{
    char *ret_val;
    char *find;
    ret_val = fgets(st, n, stdin);
    if (ret_val)
    {
        find = strchr(st, '\n'); // 查找换行符
        if (find)                // 如果地址不是 NULL，
            *find = '\0';        // 在此处放置一个空字符
        else
            while (getchar() != '\n')
                continue; // 处理输入行的剩余内容
    }
    return ret_val;
}

```